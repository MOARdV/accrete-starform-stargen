
/*
 * Display.c : Main program for planetary system generation program.
 *
 * Description :
 *
 * This program 'builds' a planetary system (see dole.c or accrete2.c)
 * from a dust cloud surrounding a randomly-generated star.  The
 * display is similar to that found in Dole's paper, with the planet's
 * orbital distance displayed on a logrithmic scale, along with the
 * diameter, mass and eccentricity.  In addition, the star's ecosphere is
 * also displayed just above the scale. Various parameters of a planet
 * are displayed by clicking the left mouse button near the planet's
 * position, another system is generated by clicking the right mouse
 * button.
 *
 * Things to do :
 *  1.  Well, the user interface is still fairly primitive.  The big
 *      problem is that it takes 15-20 seconds to generate a system, and
 *      there's no way to skip that if you don't feel like working
 *      through 6 straight M dwarfs to finally get something with some
 *      potential.
 *  2.  No moons or asteroid belts.
 *  3.  No binary stars.
 *  4.  The planetary statistics are still a bit rough, I think I've
 *      left out a few things like atmospheric content, min/max
 *      temperatures, etc.
 *  5.  Planet's orbits are all in the same plane, add inclination and
 *      all the other orbital parameters.
 *  6.  No hardcopy output.
 *  7.  Find a way to speed it up by at least a factor of 5, see 'dole.c'.
 *
 * Author : Andrew Folkins
 *
 * Address : USENET     : ...!alberta!uqv-mts!rama
 *           Compuserve : 72060,740
 *           Real World : Edmonton, AB, Canada
 *
 * Date : September 18, 1988
 *
 * Computer Stuff : This code was written using the Lattice C 4.0
 *                  compiler for an Amiga 1000.
 *
 * Legal stuff : This code is released into the public domain.
 *               Permission is granted to fold, bend, spindle and/or
 *               mutilate this code, just keep the pieces together
 *               and let me know if you use it for anything.
 */

#include <exec/types.h>
#include <graphics/gfxbase.h>
#include <graphics/gfxmacros.h>
#include <intuition/intuition.h>
#include <stdio.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/exec.h>

#include "system.h"

extern struct IntuitionBase *IntuitionBase;
extern struct GfxBase *GfxBase;

struct Star star;

struct NewWindow planet_nw = {
   0, 125, 640, 75,
   -1, -1,
   NULL,
   WINDOWCLOSE | WINDOWDRAG | WINDOWDEPTH | NOCAREREFRESH,
   NULL,         /* Gadget list */
   NULL,         /* Checkmark   */
   "Planet Display Window",
   NULL,         /* Screen      */
   NULL,         /* Bitmap      */
   0, 0, 0, 0,   /* minwidth, minheight, maxwidth, maxheight */
   WBENCHSCREEN
};

struct NewWindow system_nw = {
   0, 0, 640, 125,
   -1, -1,
   CLOSEWINDOW | MOUSEBUTTONS,
   WINDOWCLOSE | WINDOWDRAG | WINDOWDEPTH | NOCAREREFRESH | RMBTRAP,
   NULL,         /* Gadget list */
   NULL,         /* Checkmark   */
   "System Display Window",
   NULL,         /* Screen      */
   NULL,         /* Bitmap      */
   0, 0, 0, 0,   /* minwidth, minheight, maxwidth, maxheight */
   WBENCHSCREEN
};

struct Screen *screen;
struct Window *system_window, *planet_window;

void FreeList(list)
struct List *list;
{
   while (!ListEmpty(list))
      free((char *)RemHead(list));
}

void CloseStuff(rc)
short rc;
{
   char *msg;

   if (rc != 0) {
      switch(rc) {
         case 1 : msg = "Couldn't open intuition.lib\n"; break;
         case 2 : msg = "Couldn't open graphics.lib\n"; break;
         case 3 : msg = "Couldn't open window\n"; break;
      }
      fprintf(stderr, "%s", msg);
   }

   if (planet_window) {
      planet_window->UserPort = NULL;
      CloseWindow(planet_window);
   }
   if (system_window) CloseWindow(system_window);
   if (GfxBase) CloseLibrary((struct Library *)GfxBase);
   if (IntuitionBase) CloseLibrary((struct Library *)IntuitionBase);
}

void OpenStuff()
{
#define OS_VERSION 33
   IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library", OS_VERSION);
   if (!IntuitionBase) CloseStuff(1);

   GfxBase = (struct GfxBase *)OpenLibrary("graphics.library", OS_VERSION);
   if (!GfxBase) CloseStuff(2);

   system_window = OpenWindow(&system_nw);
   if (!system_window) CloseStuff(3);
}

void ClearWindow(w)
struct Window *w;
{
   SetAPen(w->RPort, 0);
   RectFill(w->RPort, w->BorderLeft, w->BorderTop,
                      w->Width - w->BorderRight, w->Height - w->BorderBottom);
   SetAPen(w->RPort, 1);
}

/* System display routines */

/*
 * Compute the screen position of a given orbital distance.
 */
short computex(r)
double r;
{
   return((short)((log10(r) + 1.1) * system_window->Width / 3.25));
}

#define AXISHEIGHT 30

void DrawOrbitLimits(min, r, max, offset, height)
float min, r, max;
short offset, height;
{
   short x0, x1, x2, y;

   y = system_window->Height - AXISHEIGHT - offset;
   x0 = computex(min);
   x1 = computex(r);
   x2 = computex(max);

   Move(system_window->RPort, x0, y);
   Draw(system_window->RPort, x0, y+height);
   Draw(system_window->RPort, x2, y+height);
   Draw(system_window->RPort, x2, y);
   Move(system_window->RPort, x1, y);
   Draw(system_window->RPort, x1, y+height);
}

void DrawXAxis()
{
   short i, x, y;
   double r;

   y = system_window->Height - AXISHEIGHT;
   SetAPen(system_window->RPort, 1);
   for (i = 1; i <= 10; i++) {
      r = i;
      x = computex(r);
      Move(system_window->RPort, x, y);
      Draw(system_window->RPort, x, y-5);
      x = computex(r / 10.0);
      Move(system_window->RPort, x, y);
      Draw(system_window->RPort, x, y-5);
      x = computex(r * 10.0);
      Move(system_window->RPort, x, y);
      Draw(system_window->RPort, x, y-5);
   }
   Move (system_window->RPort, x, y);
   x = computex(0.1);
   Draw(system_window->RPort, x, y);

   y += 10;
   Move(system_window->RPort, computex(0.1), y); Text(system_window->RPort, "0.1", 3);
   Move(system_window->RPort, computex(1.0), y); Text(system_window->RPort, "1", 1);
   Move(system_window->RPort, computex(10.0), y); Text(system_window->RPort, "10", 2);
   Move(system_window->RPort, computex(90.0), y); Text(system_window->RPort, "100", 3);

   Move(system_window->RPort, computex(0.5), y + 10);
   Text(system_window->RPort, "Semi-Major Axis (Astronomical Units)", 36);
}

void DisplayPlanet(p, color)
struct Planet *p;
short color;
{
   char buffer[16];
   char *b;
   char *format;

   if (p->mass < 0.01) return;            /* skip the gravel */

   SetAPen(system_window->RPort, color);

   p->x = computex(p->r);
   p->y = 60;
   if (p->flags & GAS) {
      p->dradius = p->radius / 2500.0;
      DrawEllipse(system_window->RPort, p->x, p->y, p->dradius, p->dradius >> 1);
   } else {
      p->dradius = 1;
      DrawCircle(system_window->RPort, p->x, p->y, p->dradius);
   }
   if (p->mass < 1) format = "%2.2f";
   else if (p->mass < 100) format = "%.1f";
   else format = "%.0f";

   sprintf(buffer, format, p->mass);
   Move(system_window->RPort, p->x - strlen(buffer) * 4,
                       p->y - ((p->dradius >> 1) + 5));
   b = buffer;
   if (*b == '0') b++;
   Text(system_window->RPort, b, strlen(b));

   DrawOrbitLimits(p->r * (1.0 - p->e), p->r, p->r * (1.0 + p->e), 15, 5);
}

struct Planet *SelectedPlanet = NULL;
#define NSTATS 8
char StatsBuf[NSTATS][60];

void DisplayPrimaryStats(star)
struct Star *star;
{
   short i;

   sprintf(StatsBuf[0], "Primary spectral class %c%d %s", star->spc_class,
           star->spc_subclass, LuminosityClass[star->lum_class]);
   sprintf(StatsBuf[1], "Luminosity %.4G Sol", star->luminosity);
   sprintf(StatsBuf[2], "Mass %.4G Sol", star->mass);

   SetAPen(system_window->RPort, 1);
   for (i = 0; i < 3; i++) {
      Move(system_window->RPort, 5, i * 9 + system_window->BorderTop + 7);
      Text(system_window->RPort, StatsBuf[i], strlen(StatsBuf[i]));
   }
}

void DisplaySystem(star)
struct Star *star;
{
   struct Node *n;

   ClearWindow(system_window);
   DrawXAxis();
   DisplayPrimaryStats(star);
   if (star->r_inner > 0.1)
      DrawOrbitLimits(star->r_inner, star->r_ecos, star->r_outer, 9, 2);
   for (n = star->PlanetList.lh_Head; n->ln_Succ; n = n->ln_Succ)
      DisplayPlanet((struct Planet *)n, 1);
}

struct Planet *FindPlanet(x, y)
short x, y;
{
   struct Node *n;
   struct Planet *p, *minp;
   long min, distance;

   if (ListEmpty(&star.PlanetList)) return(NULL);

   /* find selected planet */
   min = 1000000;
   for (n = star.PlanetList.lh_Head; n->ln_Succ; n = n->ln_Succ) {
      p = (struct Planet *)n;
      distance = (x - p->x) * (x - p->x) + (y - p->y) * (y - p->y);
      if (distance < min) {
         min = distance;
         minp = p;
      }
   }
   return(minp);
}


void DisplayPlanetStats(x, y)
short x, y;
{
   struct Planet *p;
   short i;

   if (SelectedPlanet)
      DisplayPlanet(SelectedPlanet, 1);

   if ((p = FindPlanet(x, y)) == NULL) return;

   if (planet_window == NULL) {
      planet_nw.IDCMPFlags = NULL;
      planet_window = OpenWindow(&planet_nw);
      if (!planet_window) return(FALSE);
      planet_window->UserPort = system_window->UserPort;
      ModifyIDCMP(planet_window, CLOSEWINDOW);
   }

   WindowToFront(planet_window);

   SelectedPlanet = p;
   DisplayPlanet(p, 3);

   /* display selected planet's stats */
   sprintf(StatsBuf[0], "Planet   %2d", p->n);
   sprintf(StatsBuf[1], "Mass (x Earth)        %7.3f", p->mass);
   sprintf(StatsBuf[2], "Semi-Major Axis       %7.2f AU", p->r);
   sprintf(StatsBuf[3], "Orbital Eccentricity  %7.2f", p->e);
   sprintf(StatsBuf[4], "Equatorial Radius     %7.0f km", p->radius);
   sprintf(StatsBuf[5], "Density (x water)     %4.2f", p->density);

   SetAPen(planet_window->RPort, 1);
   for (i = 0; i < 6; i++) {
      Move(planet_window->RPort, 5, i * 9 + planet_window->BorderTop + 7);
      Text(planet_window->RPort, StatsBuf[i], strlen(StatsBuf[i]));
   }

   if (p->year < 2.0)
      sprintf(StatsBuf[0], "Year   %10.3f days ", p->year * 365.24);
   else
      sprintf(StatsBuf[0], "Year   %10.3f years", p->year);
   if (p->rotation_rate == 0.0)
      sprintf(StatsBuf[1], "Day    Synchronous    ");
   else if (p->rotation_rate > 100.0)
      sprintf(StatsBuf[1], "Day    %8.2f days", p->rotation_rate / 24.0);
   else
      sprintf(StatsBuf[1], "Day    %8.2f hours", p->rotation_rate);
   sprintf(StatsBuf[2], "Gravity  %4.2f g", p->surface_gravity / 9.8);
   sprintf(StatsBuf[3], "Escape Velocity %6.2f km/sec", p->esc_velocity);
   sprintf(StatsBuf[4], "Surface Temperature %3.0f K", p->temperature);

   for (i = 0; i < 5; i++) {
      Move(planet_window->RPort, 300, i * 9 + planet_window->BorderTop + 7);
      Text(planet_window->RPort, StatsBuf[i], strlen(StatsBuf[i]));
   }
}

/* System creation routines */

void GenerateSystem(star)
struct Star *star;
{
   GenStar(star);
   NewList(&star->PlanetList);
   switch (star->spc_class) {
      case 'O' :
      case 'B' :
      case 'A' :
         break;    /* These guys don't get planets */
      case 'F' :
      case 'G' :
      case 'K' :
      case 'M' :
         if (star->lum_class >= 4 && star->lum_class <= 6) {
            SetWindowTitles(system_window, "Creating System", (char *)-1);
            ClearWindow(system_window);
            DisplayPrimaryStats(star);
            CreateSystem(star);
            SetWindowTitles(system_window, system_nw.Title, (char *)-1);
         }
   }
}

void FreeStar(star)
struct Star *star;
{
   FreeList(&star->PlanetList);
}


void ClosePlanetWindow()
{
   if (!planet_window) return;
   planet_window->UserPort = NULL;
   planet_nw.TopEdge = planet_window->TopEdge;
   planet_nw.LeftEdge = planet_window->LeftEdge;
   CloseWindow(planet_window);
   planet_window = NULL;
   if (SelectedPlanet) {
      DisplayPlanet(SelectedPlanet, 1);
      SelectedPlanet = NULL;
   }
}

void DoMessages()
{
   struct IntuiMessage *message;
   ULONG class;
   USHORT code;
   SHORT mousex, mousey;
   struct Window *iw;

   DisplaySystem(&star);
   for (;;) {
      Wait(1 << system_window->UserPort->mp_SigBit);
      while (message = (struct IntuiMessage *)GetMsg(system_window->UserPort)) {
         mousex = message->MouseX;
         mousey = message->MouseY;
         class = message->Class;
         code = message->Code;
         iw = message->IDCMPWindow;
         ReplyMsg((struct Message *)message);
         switch(class) {
            case MOUSEBUTTONS :
               if (code == SELECTDOWN)
                  DisplayPlanetStats(mousex, mousey);
               if (code == MENUDOWN) {
                  ClosePlanetWindow();
                  FreeStar(&star);
                  GenerateSystem(&star);
                  DisplaySystem(&star);
               }
               break;
            case CLOSEWINDOW :
               if (iw == planet_window)
                  ClosePlanetWindow();
               else
                  return;
         }
      }
   }
}

void main(argc, argv)
int argc;
char *argv[];
{
   OpenStuff();
   InitGenStar();
   GenerateSystem(&star);

   DoMessages();

   FreeStar(&star);
   CloseStuff(0);
}

